# =============================================================================
# CI PIPELINE - Task Manager API
# =============================================================================
# This pipeline implements a production-grade CI workflow with:
# - Code Quality (Linting)
# - Security Scanning (SAST, SCA)
# - Testing (Unit Tests)
# - Containerization (Docker Build, Image Scan)
# - Registry Push (DockerHub)
#
# WHY CI/CD? Manual processes lead to human errors, inconsistent environments,
# and security vulnerabilities. This pipeline ensures only tested, secure,
# and validated code reaches production.
# =============================================================================

name: CI Pipeline

on:
  push:
    branches:
      - master
      - main
  pull_request:
    branches:
      - master
      - main
  workflow_dispatch: 

env:
  JAVA_VERSION: '17'
  DOCKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/task-manager-api

jobs:
  # ===========================================================================
  # STAGE 1: CHECKOUT & SETUP
  # ===========================================================================
  # WHY: Retrieves source code and caches dependencies for faster builds.
  # Without proper setup, builds would be inconsistent across different runners.
  # Maven caching reduces build time by ~60% on subsequent runs.
  # ===========================================================================
  checkout-and-setup:
    name: Checkout & Setup
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better analysis

      - name: Setup Java JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Generate Cache Key
        id: cache-key
        run: echo "key=${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}" >> $GITHUB_OUTPUT

      - name: Cache Maven Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ steps.cache-key.outputs.key }}
          restore-keys: |
            ${{ runner.os }}-maven-

  # ===========================================================================
  # STAGE 2: LINTING (Code Quality)
  # ===========================================================================
  # WHY: Enforces coding standards automatically before code review.
  # RISK MITIGATED: Technical debt, inconsistent code style, maintainability issues
  # SHIFT-LEFT BENEFIT: Catches style issues early, saves reviewer time
  # TOOL: Checkstyle - enforces Google Java Style Guide
  # ===========================================================================
  linting:
    name: Linting (Checkstyle)
    runs-on: ubuntu-latest
    needs: checkout-and-setup
    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4

      - name: Setup Java JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Run Checkstyle Analysis
        run: mvn checkstyle:check -B
        # Pipeline FAILS if code style violations found
        # This enforces consistent code quality across the team

      - name: Upload Checkstyle Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: checkstyle-report
          path: target/checkstyle-result.xml
          retention-days: 7

  # ===========================================================================
  # STAGE 3: SAST (Static Application Security Testing)
  # ===========================================================================
  # WHY: Analyzes source code for security vulnerabilities WITHOUT executing it
  # RISK MITIGATED: OWASP Top 10 vulnerabilities:
  #   - SQL Injection
  #   - Cross-Site Scripting (XSS)
  #   - Insecure Deserialization
  #   - Security Misconfigurations
  # SHIFT-LEFT BENEFIT: Finds vulnerabilities at code-write time, not production
  # TOOL: GitHub CodeQL - semantic code analysis engine
  # ===========================================================================
  sast:
    name: SAST (CodeQL)
    runs-on: ubuntu-latest
    needs: checkout-and-setup
    permissions:
      actions: read
      contents: read
      security-events: write  # Required to upload SARIF to Security tab
    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: java
          # CodeQL analyzes Java bytecode for deeper vulnerability detection

      - name: Setup Java JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Build for CodeQL Analysis
        run: mvn compile -B -DskipTests

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
        with:
          category: "/language:java"
          # Results appear in GitHub Security tab > Code scanning alerts

  # ===========================================================================
  # STAGE 4: SCA (Software Composition Analysis)
  # ===========================================================================
  # WHY: Scans third-party dependencies for known vulnerabilities (CVEs)
  # RISK MITIGATED: Supply chain attacks, vulnerable libraries
  # EXAMPLE: Log4Shell (CVE-2021-44228) would be detected here
  # TOOL: OWASP Dependency Check - scans against National Vulnerability Database
  # ===========================================================================
  sca:
    name: SCA (Dependency Check)
    runs-on: ubuntu-latest
    needs: checkout-and-setup
    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4

      - name: Setup Java JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Run OWASP Dependency Check
        run: mvn dependency-check:check -B
        continue-on-error: true  # Report vulnerabilities but don't block
        # In production, set failBuildOnCVSS threshold in pom.xml

      - name: Upload Dependency Check Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dependency-check-report
          path: target/dependency-check-report.html
          retention-days: 7

  # ===========================================================================
  # STAGE 5: UNIT TESTS
  # ===========================================================================
  # WHY: Validates business logic works correctly
  # RISK MITIGATED: Regressions, broken functionality
  # FAIL-FAST: If tests fail, pipeline stops - no point building broken code
  # TOOL: JUnit 5 + JaCoCo for test execution and code coverage
  # ===========================================================================
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: checkout-and-setup
    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4

      - name: Setup Java JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Run Unit Tests with Coverage
        run: mvn test jacoco:report -B
        # Tests MUST pass - this is a quality gate

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: target/surefire-reports/
          retention-days: 7

      - name: Upload Coverage Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: target/site/jacoco/
          retention-days: 7

  # ===========================================================================
  # STAGE 6: BUILD APPLICATION
  # ===========================================================================
  # WHY: Compiles code and packages into deployable JAR artifact
  # RISK MITIGATED: Compilation errors, missing dependencies
  # DEPENDENCY: Only runs after linting and tests pass (fail-fast)
  # ===========================================================================
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [linting, unit-tests]  # Only build if quality checks pass
    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4

      - name: Setup Java JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Build Application JAR
        run: mvn clean package -DskipTests -B
        # Tests already ran - skip here for faster builds

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: target/*.jar
          retention-days: 7

  # ===========================================================================
  # STAGE 7: DOCKER BUILD
  # ===========================================================================
  # WHY: Creates immutable container image ensuring consistency
  # RISK MITIGATED: "Works on my machine" problem
  # BEST PRACTICE: Multi-stage build reduces image size and attack surface
  # ===========================================================================
  docker-build:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4

      - name: Setup Java JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Build JAR for Docker
        run: mvn clean package -DskipTests -B

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: |
            ${{ env.DOCKER_IMAGE }}:${{ github.sha }}
            ${{ env.DOCKER_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Save Docker Image for Later Stages
        run: docker save ${{ env.DOCKER_IMAGE }}:${{ github.sha }} -o image.tar

      - name: Upload Docker Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: image.tar
          retention-days: 1

  # ===========================================================================
  # STAGE 8: IMAGE SCAN (Container Vulnerability Scan)
  # ===========================================================================
  # WHY: Scans container for OS and library vulnerabilities
  # RISK MITIGATED: Vulnerable base images, outdated packages in container
  # DIFFERENCE FROM SCA: SCA scans app dependencies; Trivy scans entire container
  # TOOL: Aqua Trivy - comprehensive container scanner
  # ===========================================================================
  image-scan:
    name: Image Scan (Trivy)
    runs-on: ubuntu-latest
    needs: docker-build
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker Image
        run: docker load -i image.tar

      - name: Run Trivy Vulnerability Scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.DOCKER_IMAGE }}:${{ github.sha }}'
          format: 'table'
          exit-code: '0'  # Report but don't fail
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Generate SARIF Report for GitHub Security Tab
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.DOCKER_IMAGE }}:${{ github.sha }}'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy Results to GitHub Security Tab
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
          # Results appear in GitHub Security tab > Code scanning alerts

  # ===========================================================================
  # STAGE 9: RUNTIME TEST (Container Smoke Test)
  # ===========================================================================
  # WHY: Validates the container actually starts and responds correctly
  # RISK MITIGATED: Container crashes, misconfigured entrypoints
  # CRITICAL: A container can BUILD successfully but FAIL to run
  # ===========================================================================
  runtime-test:
    name: Runtime Test (Smoke Test)
    runs-on: ubuntu-latest
    needs: docker-build
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker Image
        run: docker load -i image.tar

      - name: Start Container
        run: |
          docker run -d --name test-container -p 8080:8080 ${{ env.DOCKER_IMAGE }}:${{ github.sha }}
          echo "Waiting for application startup..."
          sleep 30

      - name: Verify Health Endpoint
        run: |
          echo "Checking /health endpoint..."
          for i in {1..5}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health)
            if [ "$response" = "200" ]; then
              echo "âœ… Health check PASSED (HTTP $response)"
              exit 0
            fi
            echo "Attempt $i: HTTP $response - retrying..."
            sleep 5
          done
          echo "âŒ Health check FAILED"
          docker logs test-container
          exit 1

      - name: Verify API Endpoints
        run: |
          echo "Testing root endpoint..."
          curl -f http://localhost:8080/ || exit 1
          echo "âœ… Root endpoint PASSED"

          echo "Testing /api/tasks endpoint..."
          curl -f http://localhost:8080/api/tasks || exit 1
          echo "âœ… Tasks endpoint PASSED"

          echo "Testing POST /api/tasks..."
          curl -f -X POST http://localhost:8080/api/tasks \
            -H "Content-Type: application/json" \
            -d '{"title":"CI Test Task","description":"Created during CI pipeline"}' || exit 1
          echo "âœ… Create task PASSED"

          echo "=========================================="
          echo "   ALL SMOKE TESTS PASSED"
          echo "=========================================="

      - name: Show Container Logs
        if: always()
        run: docker logs test-container

      - name: Cleanup
        if: always()
        run: |
          docker stop test-container || true
          docker rm test-container || true

  # ===========================================================================
  # STAGE 10: PUSH TO DOCKER REGISTRY
  # ===========================================================================
  # WHY: Publishes trusted, validated image to DockerHub
  # RISK MITIGATED: Only images that pass ALL checks reach the registry
  # ENABLES: Downstream CD pipeline can pull trusted image
  # CONDITION: Only pushes on master/main branch (not PRs)
  # ===========================================================================
  docker-push:
    name: Push to DockerHub
    runs-on: ubuntu-latest
    needs: [image-scan, runtime-test, sast, sca]  # All security checks must pass
    if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main')
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker Image
        run: docker load -i image.tar

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Tag Image with Latest
        run: |
          docker tag ${{ env.DOCKER_IMAGE }}:${{ github.sha }} ${{ env.DOCKER_IMAGE }}:latest

      - name: Push Image to DockerHub
        run: |
          echo "Pushing image with commit SHA tag..."
          docker push ${{ env.DOCKER_IMAGE }}:${{ github.sha }}

          echo "Pushing image with 'latest' tag..."
          docker push ${{ env.DOCKER_IMAGE }}:latest

          echo "=========================================="
          echo "   IMAGE PUSHED TO DOCKERHUB"
          echo "   ${{ env.DOCKER_IMAGE }}:${{ github.sha }}"
          echo "   ${{ env.DOCKER_IMAGE }}:latest"
          echo "=========================================="

      - name: Generate Push Summary
        run: |
          echo "## ðŸ³ Docker Image Published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ env.DOCKER_IMAGE }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Tags | \`${{ github.sha }}\`, \`latest\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Registry | DockerHub |" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # PIPELINE SUMMARY
  # ===========================================================================
  pipeline-summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [linting, sast, sca, unit-tests, build, docker-build, image-scan, runtime-test, docker-push]
    if: always()
    steps:
      - name: Generate CI Summary
        run: |
          echo "# ðŸš€ CI Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Stage Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Purpose | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|---------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Linting | Enforce coding standards | ${{ needs.linting.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| SAST | Detect code vulnerabilities | ${{ needs.sast.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| SCA | Detect vulnerable dependencies | ${{ needs.sca.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | Validate business logic | ${{ needs.unit-tests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build | Package application | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Build | Create container image | ${{ needs.docker-build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Scan | Scan container vulnerabilities | ${{ needs.image-scan.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Runtime Test | Validate container behavior | ${{ needs.runtime-test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Push | Publish to registry | ${{ needs.docker-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Security Tools Used" >> $GITHUB_STEP_SUMMARY
          echo "- **SAST**: CodeQL (code-level vulnerabilities)" >> $GITHUB_STEP_SUMMARY
          echo "- **SCA**: OWASP Dependency Check (dependency vulnerabilities)" >> $GITHUB_STEP_SUMMARY
          echo "- **Container Scan**: Trivy (OS/library vulnerabilities)" >> $GITHUB_STEP_SUMMARY
